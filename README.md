# План проведения семинаров (21.01.2026)

Дата: 21 января 2026 года (Среда, 3-я учебная неделя)
Общая тема дня: «Реализация подсистемы аутентификации: Формы, Сессии и Хеширование»

---

### ТЕМА: Проектирование БД и создание таблицы `users`
**Цель:** Создать надежный фундамент для системы аутентификации пользователей.
**Инструмент:** Хостинг Beget -> Панель управления MySQL -> phpMyAdmin.


#### ЭТАП 0. Настройка подключения к БД
Это подробная инструкция по созданию и настройке файла `db.php`. Этот файл — фундамент всего курсового проекта. Если он не работает, не работает ничего.

---

# ИНСТРУКЦИЯ: Организация подключения к БД (`db.php`)

**Зачем нужен этот файл?**
В программировании есть принцип **DRY (Don't Repeat Yourself)** — «Не повторяйся».
Вместо того чтобы прописывать логин и пароль от базы данных в каждом файле (`register.php`, `login.php`, `catalog.php`), мы пишем их **один раз** в файле `db.php`. Затем мы просто подключаем этот файл там, где нужно.

### ШАГ 1. Создание файла (Локально)

1.  Откройте **VS Code**.
2.  В папке вашего проекта создайте новый файл с именем **`db.php`**.
3.  Скопируйте в него следующий «золотой стандарт» кода подключения:

```php
<?php
/*
 * Файл конфигурации базы данных
 * Используется паттерн PDO (PHP Data Objects)
 */

// 1. НАСТРОЙКИ (Измените на свои данные из Beget!)
$host = 'localhost'; // На Beget хост ВСЕГДА localhost
$db   = 'vashlogin_shop'; // Имя базы данных (из панели MySQL)
$user = 'vashlogin_shop'; // Имя пользователя (часто совпадает с именем БД)
$pass = 'VashSlozhniyParol123'; // Пароль, который вы задали при создании БД
$charset = 'utf8mb4'; // Кодировка (поддерживает эмодзи и все языки)

// 2. DSN (Data Source Name) - строка подключения
$dsn = "mysql:host=$host;dbname=$db;charset=$charset";

// 3. ОПЦИИ PDO (Критически важны для удобства и безопасности)
$options = [
    // Выбрасывать исключения при ошибках (чтобы видеть Fatal Error, а не белый экран)
    PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
    
    // По умолчанию получать данные как ассоциативный массив ( ['email' => '...'] )
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    
    // Отключить эмуляцию подготовленных выражений (Повышает безопасность против SQLi)
    PDO::ATTR_EMULATE_PREPARES   => false,
];

try {
    // 4. ПОПЫТКА ПОДКЛЮЧЕНИЯ
    $pdo = new PDO($dsn, $user, $pass, $options);
    
    // Если мы здесь — значит подключение прошло успешно.
    // Переменная $pdo теперь содержит объект подключения.
    
} catch (\PDOException $e) {
    // 5. ОБРАБОТКА ОШИБКИ
    // В реальном проекте мы бы писали ошибку в лог-файл
    // Для обучения выводим ошибку на экран:
    throw new \PDOException($e->getMessage(), (int)$e->getCode());
}
?>
```

### ШАГ 2. Настройка учетных данных (Конфигурация)

Это самый ответственный момент. Вам нужно заменить заглушки на реальные данные с хостинга **Beget**.

1.  Зайдите в Панель управления Beget -> Раздел **MySQL**.
2.  **`$db` (Имя базы):** Скопируйте имя базы данных из левой колонки (обычно начинается с вашего логина, например `ivanov_shop`).
3.  **`$user` (Пользователь):** На Beget имя пользователя по умолчанию совпадает с именем базы. Вставьте то же самое значение.
4.  **`$pass` (Пароль):** Введите пароль, который вы создали для этой базы данных.
    *   *Забыли пароль?* В панели Beget нажмите на иконку «Карандаш» или «Ключ» рядом с базой и задайте новый. Не забудьте обновить его в `db.php`!
5.  **`$host`:** Оставьте `'localhost'`. Не пишите туда IP-адрес или домен сайта. Скрипт выполняется *внутри* сервера, поэтому база для него находится «дома» (localhost).

### ШАГ 3. Загрузка на сервер (Deploy)

1.  Откройте **FileZilla**.
2.  Подключитесь к вашему серверу.
3.  Зайдите в папку `public_html`.
4.  Перетащите файл `db.php` с левой панели (ваш компьютер) на правую (сервер).

### ШАГ 4. Как использовать этот файл в других скриптах

Теперь, когда вы создаете страницу регистрации (`register.php`) или входа (`login.php`), вам не нужно заново писать код подключения. Вы делаете так:

```php
<?php
// В самом начале файла подключаем конфигурацию
require 'db.php'; 

// Теперь нам доступна переменная $pdo
// Можем сразу делать запросы:
$stmt = $pdo->prepare("SELECT * FROM users...");
?>
```

**Разница между `require` и `include`:**
*   Мы используем **`require`** (требовать). Если файл `db.php` случайно удалится или будет назван неправильно, скрипт **остановится** с фатальной ошибкой.
*   Если использовать `include`, скрипт продолжит работу, но упадет позже при попытке обратиться к несуществующей переменной `$pdo`, что затруднит поиск ошибки.

### ШАГ 5. Типичные ошибки (Troubleshooting)

Если при открытии сайта вы видите ошибку:

1.  **`SQLSTATE[HY000] [1045] Access denied for user...`**
    *   **Причина:** Неверный логин или пароль в файле `db.php`.
    *   **Решение:** Сверьте данные с разделом MySQL в Beget. Внимательно проверьте пробелы.

2.  **`SQLSTATE[HY000] [1049] Unknown database...`**
    *   **Причина:** Ошибка в названии базы данных (переменная `$db`).
    *   **Решение:** Проверьте префикс (например, вы написали `shop`, а надо `ivanov_shop`).

3.  **`SQLSTATE[HY000] [2002] Connection refused`**
    *   **Причина:** Вы указали неверный хост (например, IP-адрес или домен).
    *   **Решение:** Верните `$host = 'localhost';`.

4.  **Белый экран (вообще ничего нет)**
    *   **Причина:** Ошибка в синтаксисе `db.php` (например, забыли точку с запятой `;`).
    *   **Решение:** Добавьте в начало файла `register.php` (или того, который запускаете) строку: `ini_set('display_errors', 1);`.

### ⚡ Безопасность (Для отличников)

В профессиональной разработке файл с паролями (`db.php`) никогда не кладут в папку `public_html`. Его кладут на уровень выше (в корень сервера), чтобы к нему нельзя было обратиться из браузера напрямую.

**Как это сделать на Beget:**
1.  В FileZilla выйдите из папки `public_html` на уровень вверх (туда, где папки `tmp`, `logs`).
2.  Положите `db.php` туда.
3.  В файлах сайта (`register.php`) измените путь подключения:
    ```php
    require '../db.php'; // Две точки означают "на уровень выше"
    ```
*Рекомендуется попробовать это после того, как все заработает в стандартном режиме.*

#### ЭТАП 1. Проектирование схемы (Theory)

Перед тем как писать SQL, надо понимать, какие данные мы храним.
**Требования к таблице `users`:**
1.  **Уникальность:** У каждого пользователя должен быть уникальный идентификатор (`id`) и уникальный логин (`email`).
2.  **Безопасность:** Пароли **НИКОГДА** не хранятся в открытом виде. Мы храним только хеш (результат работы функции `password_hash`).
3.  **Ролевая модель:** Нужно различать администратора (может добавлять товары) и клиента (может покупать).
4.  **Аудит:** Полезно знать, когда пользователь зарегистрировался (`created_at`).

---

#### ЭТАП 2. Создание Базы Данных на Beget (Practice)

1.  Зайти в панель управления Beget.
2.  Раздел **MySQL**.
3.  Создать базу данных.
    *   **Имя:** `логин_shop` (например, `one_shop`).
    *   **Пароль:** *Сгенерировать и сохранить в файл `db.php`*.
4.  Нажать кнопку **phpMyAdmin** (иконка `PMA`) напротив созданной базы.

---

#### ЭТАП 3. SQL-код таблицы `users` (Core)

В phpMyAdmin перейти во вкладку **SQL** и выполнить следующий запрос. Этот код является «золотым стандартом» для начала курсовой.

```sql
-- Установка кодировки (на всякий случай)
SET NAMES utf8mb4;

-- Удаляем таблицу, если она была создана неправильно (очистка среды)
DROP TABLE IF EXISTS `users`;

-- Создание таблицы
CREATE TABLE `users` (
  `id` INT(11) NOT NULL AUTO_INCREMENT COMMENT 'Уникальный ID',
  `email` VARCHAR(255) NOT NULL COMMENT 'Логин пользователя',
  `password_hash` VARCHAR(255) NOT NULL COMMENT 'Хеш пароля (НЕ сам пароль!)',
  `username` VARCHAR(100) DEFAULT NULL COMMENT 'Имя для отображения',
  `phone` VARCHAR(20) DEFAULT NULL COMMENT 'Телефон для связи',
  `role` ENUM('admin', 'client') NOT NULL DEFAULT 'client' COMMENT 'Роль доступа',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'Дата регистрации',
  
  PRIMARY KEY (`id`),
  UNIQUE KEY `email_unique` (`email`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**Комментарии:**
*   `VARCHAR(255)` для пароля — обязательно. Хеши алгоритмов (bcrypt, argon2) длинные. Стандартные 32 символа (как для md5) уже **не подходят**.
*   `ENGINE=InnoDB` — поддержка транзакций и внешних ключей (понадобится для заказов в будущем).
*   `utf8mb4` — полная поддержка Unicode (включая эмодзи и редкие символы).

---

#### ЭТАП 4. Наполнение тестовыми данными (Seeding)

Всем нужно создать первого пользователя (Администратора) вручную, чтобы протестировать форму входа (`login.php`), которую они будут писать на второй паре.

**Проблема:** Мы не можем просто написать `INSERT ... VALUES ('admin', '12345')`, так как система входа будет сверять хеши.
**Решение:** Сгенерировать хеш для пароля "admin123".

**SQL-запрос для вставки администратора:**

```sql
-- Пароль: admin123
-- Хеш сгенерирован заранее: $2y$10$Bp.... (пример)
-- Для учебных целей используем фиксированный хеш bcrypt для строки 'admin123'

INSERT INTO `users` (`email`, `password_hash`, `username`, `role`) VALUES
('admin@shop.local', '$2y$10$R.h.y8p.e.g.s.e.c.u.r.e.HASH.EXAMPLE.REPLACE_ME', 'Главный Админ', 'admin'),
('client@shop.local', '$2y$10$R.h.y8p.e.g.s.e.c.u.r.e.HASH.EXAMPLE.REPLACE_ME', 'Тестовый Клиент', 'client');
```

**⚡ Лайфхак для аварийного случая (Как получить реальный хеш прямо сейчас):**
Пусть создадут в корне сайта файл `hash_gen.php`, запустят его один раз и скопируют результат.

```php
<?php
// hash_gen.php
$password = 'admin123';
echo password_hash($password, PASSWORD_DEFAULT);
?>
```
*Полученную строку вставить в SQL запрос выше.*

---

#### ЭТАП 5. Чек-лист проверки (Definition of Done)

Проект готов к написанию PHP-кода, если:
1.  В phpMyAdmin слева видна таблица `users`.
2.  В структуре таблицы поле `id` имеет атрибут `AUTO_INCREMENT` (ключик).
3.  Поле `email` помечено как `UNIQUE` (серебряный ключик) — это предотвратит регистрацию дублей.
4.  В таблице есть хотя бы одна запись, и в поле `password_hash` находится длинная строка (начинается на `$2y$`), а не понятный текст.

### Возможные расширения (для сильных студентов):
Если проект сложный, стоит добавить таблицу `user_profiles` для хранения адреса доставки и привязать её к `users` через `user_id` (связь 1:1), чтобы не перегружать основную таблицу авторизации.

# ПАРА 1. ПМ.09 (13:20 – 14:55)

Тема: Обработка данных форм и безопасная регистрация пользователей.

Цель: Реализовать серверный сценарий регистрации нового пользователя с валидацией данных и безопасным сохранением пароля.


    Теоретический блок (15 мин, самостоятельная работа, ответы на вопросы):

        HTTP методы: Разница между GET и POST. Почему для регистрации нельзя использовать GET.

        Валидация данных: "Never trust user input". Проверка на пустоту, формат email (filter_var).

        Безопасность паролей (Критически важно): Почему нельзя хранить пароли в открытом виде. Функции password_hash() (алгоритм bcrypt/argon2) и понятие "соль".

    Практикум «Live Coding» (60 мин):

        Шаг 1. HTML-форма (signup.php): Создание формы с полями email, password, confirm_password. Использование Bootstrap 5 (CDN) для быстрой верстки.

        Шаг 2. Обработчик PHP:

            Прием данных через суперглобальный массив $_POST.

            Проверка: существует ли уже такой email в БД (SQL: SELECT COUNT(*)...).

            Хеширование пароля: $hash = password_hash($pass, PASSWORD_DEFAULT);.

            Запись в БД: INSERT INTO users ... через PDO Prepared Statements (закрепление материала прошлой недели).

    Отладка и тестирование (15 мин):

        Проверка регистрации через браузер.

        Просмотр таблицы users в phpMyAdmin: убедиться, что пароли выглядят как $2y$10$..., а не как «123456».

Код-сэмпл (Регистрация):
code PHP

// register.php
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $email = trim($_POST['email']);
    $pass = $_POST['password'];
    
    // Валидация
    if (empty($email) || empty($pass)) {
        die("Заполните все поля");
    }

    // Хеширование
    $hash = password_hash($pass, PASSWORD_DEFAULT);

    // Сохранение (предполагаем $pdo подключен из db.php)
    $stmt = $pdo->prepare("INSERT INTO users (email, password_hash) VALUES (?, ?)");
    try {
        $stmt->execute([$email, $hash]);
        echo "Регистрация успешна! <a href='login.php'>Войти</a>";
    } catch (PDOException $e) {
        if ($e->getCode() == 23000) { // Код дубликата unique key
            echo "Такой email уже занят.";
        } else {
            echo "Ошибка БД.";
        }
    }
}

# ПАРА 2. МДК.09.01 (15:05 – 16:40)

Тема: Работа с сессиями и механизм авторизации (Login).

Цель: Реализовать вход в систему, управление состоянием пользователя между страницами (сессии) и защиту страниц.
План занятия:

    Теоретический блок (15 мин):

        Stateless протокол HTTP: Почему сервер "забывает" пользователя после каждого запроса.

        Механизм Сессий: session_start(), файл сессии на сервере, Cookie PHPSESSID.

        Аутентификация: Сверка введенного пароля с хешем в БД (password_verify()).

    Практикум «Live Coding» (60 мин):

        Шаг 1. HTML-форма входа (login.php).

        Шаг 2. Логика авторизации:

            Поиск пользователя по email.

            Если найден -> password_verify($input_pass, $db_hash).

            Если пароль верен -> Запись данных в сессию: $_SESSION['user_id'] = $user['id'];.

        Шаг 3. Защита страниц (Access Control):

            Создание файла profile.php, доступного только авторизованным.

            Проверка: if (!isset($_SESSION['user_id'])) { header('Location: login.php'); }.

        Шаг 4. Выход (Logout): Уничтожение сессии (session_destroy()).

    Самостоятельная работа / Курсовой проект (15 мин):

        Пользователи адаптируют код под свои темы курсовых (например, добавляют поле "Имя" или "Телефон" при регистрации).

Код-сэмпл (Авторизация):
code PHP

// login.php
session_start();
require 'db.php';

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $email = $_POST['email'];
    $pass = $_POST['password'];

    $stmt = $pdo->prepare("SELECT * FROM users WHERE email = ?");
    $stmt->execute([$email]);
    $user = $stmt->fetch();

    if ($user && password_verify($pass, $user['password_hash'])) {
        // Успешный вход
        $_SESSION['user_id'] = $user['id'];
        $_SESSION['role'] = $user['role'];
        header("Location: profile.php"); // Редирект
        exit;
    } else {
        echo "Неверный логин или пароль";
    }
}

Задание для самостоятельной работы (Дома / В конце пар)

В рамках подготовки Курсового проекта (Выбран случайно) все должны к следующей неделе:

    Развернуть созданные скрипты на хостинге Beget.

    Реализовать меню навигации, которое меняется в зависимости от состояния:

        Гость видит: "Главная", "Вход", "Регистрация".

        Пользователь видит: "Главная", "Профиль", "Выход".

        Подсказка: Использовать if (isset($_SESSION['user_id'])) в HTML-шаблоне.

    Инструменты: Все примеры показываем в VS Code, заливаем через FileZilla (или плагин SFTP), проверяем на реальном домене .beget.tech. Локальный OpenServer не используем, чтобы привыкать к продакшн-среде.


    Это отличный вопрос. Данный фрагмент кода — это «сердце» логики регистрации, но сам по себе он работать не будет. Чтобы превратить его в рабочий учебный материал для семинара **21.01.2026**, нужно добавить к нему контекст: подключение к БД и HTML-форму.

# Подробная инструкция: **куда этот код вставить, чем дополнить и как это работает**.

---

### ИНСТРУКЦИЯ К СЕМИНАРУ: Реализация `register.php`

**Цель:** Создать единый файл, который и показывает форму регистрации, и обрабатывает её отправку.

#### 1. Подготовка файла (Что делают пользователи)

Студенты должны создать в VS Code файл **`register.php`** и поместить в него следующий **полный код**.

Обратите внимание: я дополнил ваш фрагмент, добавив:
1.  Подключение `require 'db.php';` (без этого переменная `$pdo` не существует).
2.  HTML-разметку (Bootstrap 5), чтобы было куда вводить данные.
3.  Вывод сообщений об ошибках в красивом блоке `alert`.

**Полный код для копирования пользователями:**

```php
<?php
// 1. Подключаем настройки БД (создан на прошлом занятии 14.01)
require 'db.php'; 

$errorMsg = '';
$successMsg = '';

// 2. Проверяем, была ли отправлена форма
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    
    // Очистка данных
    $email = trim($_POST['email']);
    $pass = $_POST['password'];
    $passConfirm = $_POST['password_confirm'];

    // 3. Валидация (Проверки)
    if (empty($email) || empty($pass)) {
        $errorMsg = "Заполните все поля!";
    } elseif (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
        $errorMsg = "Некорректный формат Email!";
    } elseif ($pass !== $passConfirm) {
        $errorMsg = "Пароли не совпадают!";
    } else {
        // 4. Если ошибок нет — ХЕШИРУЕМ и СОХРАНЯЕМ
        
        // Генерируем безопасный хеш (bcrypt)
        $hash = password_hash($pass, PASSWORD_DEFAULT);

        // Готовим SQL-запрос (Защита от SQL Injection)
        $sql = "INSERT INTO users (email, password_hash, role) VALUES (:email, :hash, 'client')";
        $stmt = $pdo->prepare($sql);

        try {
            $stmt->execute([
                ':email' => $email,
                ':hash' => $hash
            ]);
            $successMsg = "Регистрация успешна! <a href='login.php'>Войти</a>";
        } catch (PDOException $e) {
            // Код 23000 означает нарушение уникальности (дубликат email)
            if ($e->getCode() == 23000) {
                $errorMsg = "Такой email уже зарегистрирован.";
            } else {
                $errorMsg = "Ошибка БД: " . $e->getMessage();
            }
        }
    }
}
?>

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Регистрация</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light">

<div class="container mt-5">
    <div class="row justify-content-center">
        <div class="col-md-6">
            <div class="card shadow">
                <div class="card-header bg-primary text-white">
                    <h4 class="mb-0">Регистрация</h4>
                </div>
                <div class="card-body">
                    
                    <!-- Блок вывода сообщений -->
                    <?php if($errorMsg): ?>
                        <div class="alert alert-danger"><?= $errorMsg ?></div>
                    <?php endif; ?>
                    
                    <?php if($successMsg): ?>
                        <div class="alert alert-success"><?= $successMsg ?></div>
                    <?php else: ?>

                    <!-- Сама форма -->
                    <form method="POST" action="register.php">
                        <div class="mb-3">
                            <label class="form-label">Email адрес</label>
                            <input type="email" name="email" class="form-control" required>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Пароль</label>
                            <input type="password" name="password" class="form-control" required>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Подтверждение пароля</label>
                            <input type="password" name="password_confirm" class="form-control" required>
                        </div>
                        <button type="submit" class="btn btn-primary w-100">Зарегистрироваться</button>
                    </form>
                    <div class="mt-3 text-center">
                        <a href="login.php">Уже есть аккаунт? Войти</a>
                    </div>

                    <?php endif; ?>
                </div>
            </div>
        </div>
    </div>
</div>

</body>
</html>
```

#### 2. Пошаговый разбор кода (Методический комментарий)

Во время семинара (Live Coding) вы должны разобрать следующие блоки:

**А. Подключение (`require 'db.php'`)**
*   **Вопрос:** "Почему мы не пишем настройки подключения прямо здесь?"
*   **Ответ:** "Принцип DRY (Don't Repeat Yourself). Если пароль от базы изменится, мы поменяем его только в одном файле `db.php`."

**Б. Валидация (`if (empty...)`)**
*   **Акцент:** Мы проверяем данные **до** того, как начнем нагружать базу данных или процессор хешированием. Это экономит ресурсы.

**В. Хеширование (`password_hash`) — КЛЮЧЕВОЙ МОМЕНТ МДК.09.03**
*   Объясните, что переменная `$hash` будет содержать строку из 60 символов, начинающуюся на `$2y$`.
*   Покажите, что даже если два пользователя введут пароль "12345", хеши будут **разными** (благодаря "соли").

**Г. Блок `try-catch` и код 23000**
*   Мы настроили поле `email` в базе данных как `UNIQUE` (на занятии 14.01).
*   Когда мы пытаемся вставить дубль, MySQL выбрасывает ошибку.
*   PDO перехватывает её. Мы проверяем код ошибки. Если это `23000` (Integrity constraint violation), мы говорим пользователю "Email занят", а не вываливаем страшную системную ошибку.

#### 3. Порядок действий на паре (Практика)

1.  **Создание:** Польватели создают файл `register.php` в VS Code.
2.  **Загрузка:** Через FileZilla загружают файл в папку `public_html` на сервере Beget.
3.  **Тест 1 (Успех):** Открывают браузер, вводят реальные данные. Должны увидеть зеленое сообщение "Регистрация успешна".
4.  **Проверка в БД:** Заходят в phpMyAdmin на Beget, открывают таблицу `users`.
    *   *Задание:* Найти свою запись и убедиться, что поле `password_hash` нечитаемо для человека.
5.  **Тест 2 (Дубль):** Пробуют зарегистрироваться с тем же email еще раз. Должны увидеть красное сообщение "Такой email уже зарегистрирован".

#### 4. Типичные ошибки Пользователей

*   **Ошибка:** "Class 'PDO' not found" или "Undefined variable $pdo".
    *   *Решение:* Забыли строку `require 'db.php';` или файл `db.php` не загружен на сервер.
*   **Ошибка:** Белый экран после отправки формы.
    *   *Решение:* Ошибка в синтаксисе PHP. Добавьте в начало файла `ini_set('display_errors', 1);` для отладки.
*   **Ошибка:** Пароль в базе записан не полностью (обрезан).
    *   *Решение:* Поле `password_hash` в БД имеет длину меньше 60 символов (например, VARCHAR(30)). Нужно изменить структуру таблицы через phpMyAdmin (сделать VARCHAR(255)).

